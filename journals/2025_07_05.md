- #learning #reactjs #d3js
	- The following is the learning from optimising re-rendering of the map in LSR project.
	- # Map Component Performance Optimization Explanation
	- ## The Confusion: What Was Really Causing Performance Issues?
	  
	  Initially, there was confusion about what expensive calculations were happening and when. Let me clarify the actual performance bottlenecks and how they were solved.
	- ## The Real Problem Was NOT Re-execution of useMemo
	  
	  The `useMemo` dependencies were essentially the same in both versions:
	  
	  **Old code **`baseFeatures`**** useMemo dependencies:****
	  
	  ```typescript
	  
	  }, [mapTQDataData.data, props.cmsMapData, projection])
	  
	  ```
	  
	  **New code **`processedFeatures`**** useMemo dependencies:****
	  
	  ```typescript
	  
	  }, [mapTQDataData.data, props.cmsMapData, projection, pathGenerator])
	  
	  ```
	  
	  The `projection` object reference was stable in both cases, so the expensive `polylabel()` calculations were only run once during initialization, not on every hover.
	- ## The ACTUAL Performance Problems
	- ### 1. Unnecessary React Rendering Work
	  
	  **Old Code Problem:**
	- **ALL labels were always rendered** via `MapLabels` component
	- Even though only one label was visible (based on `hoveredFeature`), **all 36+ MapText components were still being rendered** on every hover
	- They just returned `null` if not hovered, but React still had to do the work of calling each component
	  
	  **New Code Solution:**
	- **Only the hovered label is rendered** via `HoverLabel` component
	- No unnecessary component creation/destruction
	- Massive reduction in React rendering overhead
	- ### 2. Object Recreation Patterns
	  
	  **Old Code Problem:**
	  
	  ```typescript
	  
	  const filteredFeatures = useMemo(() => {
	  
	  return {
	  
	    ...mapTQDataData.data,
	  
	    features: baseFeatures.map((feature) => ({  // NEW objects every time
	  
	      ...feature,
	  
	      fill: filter === "allstates" || condition ? feature.fill : "#ededed"
	  
	    }))
	  
	  };
	  
	  }, [baseFeatures, filter, mapTQDataData.data]);
	  
	  ```
	- Created new feature objects on every filter change
	- These new object references could trigger unnecessary re-renders in child components
	  
	  **New Code Solution:**
	  
	  ```typescript
	  
	  const processedFeatures: ProcessedFeature[] = [];
	  
	  const featuresMap = new Map<string, ProcessedFeature>();
	  
	  // These objects maintain the same reference across renders
	  
	  ```
	- `ProcessedFeature` objects are created once and never change
	- Stable object references prevent unnecessary re-renders
	- ### 3. Lookup Inefficiency
	  
	  **Old Code:**
	- `MapLabels` created a new `useMemo` featureMap on every render
	- Linear search patterns in some lookups
	  
	  **New Code:**
	- Pre-computed `Map` object provides O(1) lookup for hovered features
	- No repeated map creation
	- ## What Were the Expensive Calculations?
	  
	  The expensive calculations that happened once during initialization (in both old and new code) were:
	  
	  1. ****`polylabel()`**** calculations**** - Finding the optimal label position for each polygon
		- Computationally expensive algorithm that finds the pole of inaccessibility
		- Complex geometric calculations on polygon coordinates
		  
		  2. **Map projection calculations** - Converting geographic coordinates to screen coordinates
		- `projection([xy[0] + 2, xy[1]])` involving trigonometric calculations
		  
		  3. **Geometry processing for MultiPolygon features**
		- Finding the largest polygon in MultiPolygon geometries
		- Iterating through coordinates to find optimal placement
	- ## The Key Insight
	  
	  The performance issue wasn't about `useMemo` re-executing expensive calculations. The expensive calculations only ran once in both versions. 
	  
	  The real bottleneck was:
	- **Render overhead**: Too many React components rendering on each hover
	- **Object recreation**: Creating new objects that triggered unnecessary re-renders
	- **Inefficient rendering strategy**: Rendering all labels instead of just the needed one
	- ## Summary of Optimizations
	  
	  1. **Reduced React rendering work**: From 36+ components to 1 component on hover
	  
	  2. **Stable object references**: Preventing cascade re-renders
	  
	  3. **Efficient lookup patterns**: O(1) Map lookups instead of linear searches
	  
	  4. **Focused rendering**: Only render what's actually needed
	  
	  The new code maintains the same expensive calculations being done once, but dramatically reduces the React rendering overhead and object creation patterns that were causing performance issues during user interactions.